#!/usr/bin/env python3
"""File GitHub issues for parity test failures.

Reads a JUnit XML test result file and creates a GitHub issue (via `gh` CLI)
if any tests failed.

Usage:
    python scripts/ci/file_parity_issues.py [--report parity-results.xml] [--dry-run]
"""

from __future__ import annotations

import argparse
import json
import subprocess
import sys
import xml.etree.ElementTree as ET
from datetime import datetime, timezone
from pathlib import Path


def parse_junit_xml(path: Path) -> dict:
    """Parse JUnit XML and extract failure information."""
    tree = ET.parse(path)
    root = tree.getroot()

    failures = []
    total = 0
    failed = 0

    for testsuite in root.iter("testsuite"):
        for testcase in testsuite.iter("testcase"):
            total += 1
            failure = testcase.find("failure")
            if failure is not None:
                failed += 1
                failures.append({
                    "name": testcase.get("name", "unknown"),
                    "classname": testcase.get("classname", ""),
                    "message": failure.get("message", ""),
                })

    return {"total": total, "failed": failed, "failures": failures}


def build_issue_body(report: dict, run_url: str) -> str:
    """Build a markdown issue body from the parsed test results."""
    today = datetime.now(timezone.utc).strftime("%Y-%m-%d")
    failures = report["failures"]

    lines = [
        "## Parity Test Failure",
        "",
        f"**{report['failed']}** of **{report['total']}** parity/compat tests failed.",
        "",
        f"- **Date:** {today}",
    ]
    if run_url:
        lines.append(f"- **Workflow run:** {run_url}")
    lines.extend([
        "",
        "---",
        "",
        "### Failed Tests",
        "",
    ])

    for f in failures[:50]:
        classname = f["classname"]
        name = f["name"]
        message = f["message"][:200] if f["message"] else ""
        lines.append(f"- [ ] `{classname}::{name}`")
        if message:
            lines.append(f"  > {message}")

    if len(failures) > 50:
        lines.append(f"\n... and {len(failures) - 50} more failures (see workflow run)")

    lines.extend([
        "",
        "---",
        "",
        "*This issue was auto-generated by the parity test workflow.*",
    ])

    return "\n".join(lines)


def build_issue_title(report: dict) -> str:
    """Build a concise issue title."""
    today = datetime.now(timezone.utc).strftime("%Y-%m-%d")
    return f"Parity test failure: {report['failed']} test(s) failed ({today})"


def check_duplicate_issues(label: str) -> dict | None:
    """Check if an open issue with the given label already exists."""
    try:
        result = subprocess.run(
            ["gh", "issue", "list", "--state", "open", "--label", label,
             "--json", "number,title", "--limit", "1"],
            capture_output=True, text=True, check=True,
        )
        issues = json.loads(result.stdout)
        if issues:
            return issues[0]
    except (subprocess.CalledProcessError, FileNotFoundError, json.JSONDecodeError):
        pass
    return None


def file_issue(title: str, body: str, labels: list[str], dry_run: bool) -> bool:
    """Create a GitHub issue using the gh CLI."""
    cmd = ["gh", "issue", "create", "--title", title, "--body", body]
    for label in labels:
        cmd.extend(["--label", label])

    if dry_run:
        print("DRY RUN -- would create issue:")
        print(f"  Title: {title}")
        print(f"\nBody:\n{body}")
        return True

    print(f"Creating issue: {title}")
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        print(f"Issue created: {result.stdout.strip()}")
        return True
    except subprocess.CalledProcessError as e:
        print(f"ERROR: gh issue create failed: {e.stderr}")
        return False


def add_comment(issue_number: int, body: str, dry_run: bool) -> bool:
    """Add a comment to an existing issue."""
    cmd = ["gh", "issue", "comment", str(issue_number), "--body", body]

    if dry_run:
        print(f"DRY RUN -- would comment on issue #{issue_number}")
        return True

    try:
        subprocess.run(cmd, capture_output=True, text=True, check=True)
        print(f"Comment added to issue #{issue_number}")
        return True
    except subprocess.CalledProcessError as e:
        print(f"ERROR: gh issue comment failed: {e.stderr}")
        return False


def main() -> int:
    parser = argparse.ArgumentParser(description="File GitHub issues for parity test failures")
    parser.add_argument(
        "--report", type=Path, default=Path("parity-results.xml"),
        help="Path to the JUnit XML test report (default: parity-results.xml)",
    )
    parser.add_argument(
        "--run-url", type=str, default="",
        help="URL to the GitHub Actions workflow run",
    )
    parser.add_argument(
        "--dry-run", action="store_true",
        help="Print what would be filed without actually creating an issue",
    )
    args = parser.parse_args()

    if not args.report.exists():
        print(f"ERROR: Report file not found: {args.report}")
        return 1

    report = parse_junit_xml(args.report)

    if report["failed"] == 0:
        print("All parity tests passed -- nothing to file.")
        return 0

    title = build_issue_title(report)
    body = build_issue_body(report, args.run_url)
    labels = ["parity-failure", "automated"]

    if not args.dry_run:
        existing = check_duplicate_issues("parity-failure")
        if existing:
            print(f"Existing open parity issue found: #{existing['number']} - {existing['title']}")
            return 0 if add_comment(existing["number"], body, args.dry_run) else 1

    success = file_issue(title, body, labels, args.dry_run)
    return 0 if success else 1


if __name__ == "__main__":
    sys.exit(main())
