#!/usr/bin/env python3
"""File GitHub issues for newly detected API drift.

Reads api-drift-report.json and creates a GitHub issue (via `gh` CLI)
if there are NEW missing functions that weren't in the previous baseline.

Usage:
    python scripts/ci/file_api_drift_issues.py [--report api-drift-report.json] [--dry-run]
"""

from __future__ import annotations

import argparse
import json
import subprocess
import sys
from pathlib import Path


def build_issue_body(report: dict) -> str:
    """Build a markdown issue body from the drift report."""
    new_drift = report.get("new_drift_by_module", {})
    summary = report.get("summary", {})
    timestamp = report.get("timestamp", "unknown")
    librosa_ver = report.get("librosa_version", "unknown")
    madmom_ver = report.get("madmom_version", "unknown")

    total_new = sum(len(v) for v in new_drift.values())

    lines = [
        "## API Drift Detected",
        "",
        f"**{total_new}** new uncovered API(s) found in upstream libraries.",
        "",
        f"- **Date:** {timestamp}",
        f"- **librosa version:** {librosa_ver}",
        f"- **madmom version:** {madmom_ver}",
        f"- **Overall coverage:** {summary.get('total_covered', '?')}"
        f"/{summary.get('total_upstream_apis', '?')}"
        f" ({summary.get('coverage_pct', '?')}%)",
        "",
        "---",
        "",
    ]

    # Group by library (librosa vs madmom)
    librosa_drift: dict[str, list[str]] = {}
    madmom_drift: dict[str, list[str]] = {}
    for mod, names in sorted(new_drift.items()):
        if mod.startswith("madmom"):
            madmom_drift[mod] = names
        else:
            librosa_drift[mod] = names

    if librosa_drift:
        lines.append("### librosa")
        lines.append("")
        for mod, names in sorted(librosa_drift.items()):
            lines.append(f"**`{mod}`** ({len(names)} new):")
            lines.append("")
            for name in sorted(names):
                lines.append(f"- [ ] `{mod}.{name}`")
            lines.append("")

    if madmom_drift:
        lines.append("### madmom")
        lines.append("")
        for mod, names in sorted(madmom_drift.items()):
            lines.append(f"**`{mod}`** ({len(names)} new):")
            lines.append("")
            for name in sorted(names):
                lines.append(f"- [ ] `{mod}.{name}`")
            lines.append("")

    lines.extend([
        "---",
        "",
        "### Action Required",
        "",
        "For each new API above, decide whether to:",
        "1. **Implement** it in the compat shim",
        "2. **Skip** it by adding to the skip list in "
        "`scripts/ci/check_api_surface.py` and `Tests/test_compat_completeness.py`",
        "",
        "*This issue was auto-generated by the API drift detection workflow.*",
    ])

    return "\n".join(lines)


def build_issue_title(report: dict) -> str:
    """Build a concise issue title."""
    new_drift = report.get("new_drift_by_module", {})
    total_new = sum(len(v) for v in new_drift.values())

    # Identify which libraries have drift
    libraries = set()
    for mod in new_drift:
        if mod.startswith("madmom"):
            libraries.add("madmom")
        else:
            libraries.add("librosa")

    lib_str = " & ".join(sorted(libraries))
    return f"API drift: {total_new} new uncovered function(s) in {lib_str}"


def file_issue(title: str, body: str, labels: list[str], dry_run: bool) -> bool:
    """Create a GitHub issue using the gh CLI."""
    cmd = ["gh", "issue", "create", "--title", title, "--body", body]
    for label in labels:
        cmd.extend(["--label", label])

    if dry_run:
        print("DRY RUN -- would execute:")
        print(f"  {' '.join(cmd[:6])} ...")
        print(f"\nTitle: {title}")
        print(f"\nBody:\n{body}")
        return True

    print(f"Creating issue: {title}")
    try:
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        print(f"Issue created: {result.stdout.strip()}")
        return True
    except subprocess.CalledProcessError as e:
        print(f"ERROR: gh issue create failed: {e.stderr}")
        return False
    except FileNotFoundError:
        print("ERROR: `gh` CLI not found. Install from https://cli.github.com/")
        return False


def check_duplicate_issues(title_prefix: str) -> bool:
    """Check if an open issue with a similar title already exists."""
    try:
        result = subprocess.run(
            ["gh", "issue", "list", "--state", "open", "--search", title_prefix,
             "--json", "title", "--limit", "5"],
            capture_output=True, text=True, check=True,
        )
        issues = json.loads(result.stdout)
        for issue in issues:
            if issue.get("title", "").startswith("API drift:"):
                print(f"Existing open drift issue found: {issue['title']}")
                return True
    except (subprocess.CalledProcessError, FileNotFoundError, json.JSONDecodeError):
        # If we can't check, proceed with filing
        pass
    return False


def main() -> int:
    parser = argparse.ArgumentParser(description="File GitHub issues for API drift")
    parser.add_argument(
        "--report", type=Path, default=Path("api-drift-report.json"),
        help="Path to the API drift report (default: api-drift-report.json)",
    )
    parser.add_argument(
        "--dry-run", action="store_true",
        help="Print what would be filed without actually creating an issue",
    )
    parser.add_argument(
        "--label", action="append", default=[],
        help="Labels to apply to the issue (can be specified multiple times)",
    )
    args = parser.parse_args()

    # Default labels
    if not args.label:
        args.label = ["api-drift", "automated"]

    # Load report
    if not args.report.exists():
        print(f"ERROR: Report file not found: {args.report}")
        return 1

    try:
        report = json.loads(args.report.read_text())
    except json.JSONDecodeError as e:
        print(f"ERROR: Could not parse report: {e}")
        return 1

    # Check for new drift
    new_drift = report.get("new_drift_by_module", {})
    total_new = sum(len(v) for v in new_drift.values())

    if total_new == 0:
        print("No new drift detected -- nothing to file.")
        return 0

    # Check for existing open issues to avoid duplicates
    if not args.dry_run and check_duplicate_issues("API drift:"):
        print("Skipping issue creation -- an open drift issue already exists.")
        print("Close or update the existing issue first.")
        return 0

    # Build and file the issue
    title = build_issue_title(report)
    body = build_issue_body(report)

    success = file_issue(title, body, args.label, args.dry_run)
    return 0 if success else 1


if __name__ == "__main__":
    sys.exit(main())
